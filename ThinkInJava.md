## 第 1 章  对象入门
面向对象编程（OOP）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析
与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高
雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。

### 1.1 抽象的进步 
#### 五大基本特征:
1. 所有东西都是对象
2. 程序是一大堆对象的组合
3. 每个对象都有自己的存储空间，可容纳其他对象。
4. 每个对象都有一种类型
5. 同一类所有对象都能接收相同的消息
### 1.2 对象的接口
所有对象——尽管各有特色——都属于某一系列对象的一部分，这些对象具有通用的特征和行为。
在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据“类型”（Type），但几乎所
有面向对象的程序设计语言都采用了“class”关键字。当您看到“type”这个字的时候，请同时想到
“class”；反之亦然。
如何利用对象完成真正有用的工作呢？必须有一种办法能向对象发出请求，令其做一些实际的事情，比如完
成一次交易、在屏幕上画一些东西或者打开一个开关等等。每个对象仅能接受特定的请求。我们向对象发出
的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类
型”与“接口”的等价或对应关系是面向对象程序设计的基础。 
![例子](/image/chapter001_001.jpg)
### 1.3  实现方案的隐藏 
“接口”（Interface）规定了可对一个特定的对象发出哪些请求。然而，必须在某个地方存在着一些代码，
以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”
Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，
protected 以及暗示性的friendly(default)。若未明确指定其他关键字，则默认为后者。

“public”（公共）意味着后续的定义任何人均可使
用。

“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其
他任何人都不能访问后续的定义信息。private 在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。

“friendly (default)”（友好的）涉及“包装”或“封装”（Package）的概念——
即 Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。

“protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。

            类内部	 本包	 子类	外部包 
	public 	 √	 √	 √	 √
	protected	 √	 √	 √	 ×
	default 	 √	 √	 ×	 ×
 	private	 √	 ×	 ×	 ×
### 1.4  方案的重复使用
为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。无论如何，只要新类
达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称
作“包含”关系，比如“一辆车包含了一个变速箱”。

继承的频繁使用会大大增加程序的复杂程度。相反，新建类的时候，首先应考虑“组织”对象；这样做显得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。

### 1.5  继承：重新使用接口
在 Java 语言中，继承是通过 extends 关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的方法。

#### 1.5.1   改善基础类
**重写(Override)**覆盖继承到的那个方法，那个方法仍然没有放弃。
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。
在面向对象原则里，重写意味着可以重写任何现有方法。 

**重载(overloading)** 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
只能重载构造函数
**overwrite** 重写继承到的那个方法的代码，原方法被放弃
**重写与重载之间的区别**
区别点|	重载方法|	重写方法
参数列表|	必须修改	|一定不能修改
返回类型	|可以修改|	一定不能修改
异常	|可以修改|	可以减少或删除，一定不能抛出新的或者更广的异常
访问|	可以修改|	一定不能做更严格的限制（可以降低限制）

**总结**：方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载是一类中多态性的一种表现。

[重写与重载](http://www.runoob.com/java/java-override-overload.html)

#### 1.5.2   等价与类似关系

**等价**我们完全能够将衍生类的一
个对象换成基础类的一个对象！可将其想象成一种“纯替换”。在某种意义上，这是进行继承的一种理想方
式。此时，我们通常认为基础类和衍生类之间存在一种“等价”关系

**类似**新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们是完全等价的

### 1.6  多形对象的互换使用
继承最终会以创建一系列类收场，所有类都建立在统一的接口基础上
#### 1.6.1 动态绑定
“多态”(Polymorphic)也叫“动态绑定”(Dynamic Binding)同时也叫“迟绑定”(Late Binding)。

动态绑定是指“在执行期间（而非编译期间）判断所引用对象的实际类型，根据其实际类型调用其相应的方法。”
多态必备的三个条件1、有继承2、有重写3、父类引用指向子类对象
[多态](http://www.cnblogs.com/Gaojiecai/p/4035077.html)
#### 1.6.2   抽象的基础类和接口
**abstarct class**

**interface（接口）**关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起

abstarct class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is a"关系，即父类和派生类在概念本质上应该是相同的。对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。

page34